using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Diagnostics;

namespace UnityTK.Benchmarking
{
    /// <summary>
    /// Abstract benchmarking base class.
    /// This class can be extended to implement (micro-)benchmarks.
    /// 
    /// UnityTK's benchmarking is similar to unit testing, it can benchmark a specific unit of code (for example a linked list implementation, <see cref="UTKLinkedList{T}"/>).
    /// It can be used to very quickly set up a benchmarking environment for units and run them comfortably in the unity editor.
    /// </summary>
    public abstract class Benchmark : MonoBehaviour
    {
        /// <summary>
        /// Runs this benchmark and returns result information.
        /// </summary>
        public BenchmarkResult Run()
        {
            // Prepare
            this.Prepare();

            // Setup benchmark result and start initial label
            BenchmarkResult res = new BenchmarkResult();
            res.BeginLabel(this.GetType().Name);

            // Run benchmark
            this.RunBenchmark(res);

            // End label
            res.EndLabel();
            res.Finish();

            // Post process
            PostProcessResult(ref res);
            return res;
        }

        /// <summary>
        /// Called right before benchmarking, can be used to prepare for benchmarking.
        /// </summary>
        protected abstract void Prepare();

        /// <summary>
        /// Execute your benchmarking code in here.
        /// Important: Since this is just a simple <see cref="System.Diagnostics.Stopwatch"/> measurement, you need take possible overhead in your benchmarking code into account.
        /// The benchmark will simply record the amount of time it takes to call this method!
        /// 
        /// It is good practice to run multiple iterations of the operation you want to profile to achieve more "stable" / reliable results.
        /// </summary>
        /// <param name="bRes">The benchmarking result class that can be used to start more labels. When it is passed in, it will already be in the first label named by the class implementing this benchmark base class.</param>
        protected abstract void RunBenchmark(BenchmarkResult bRes);

        /// <summary>
        /// Can be overridden to post process the benchmarking result generated by <see cref="Run"/>.
        /// This can for example to be used to register processing overhead to the result.
        /// </summary>
        /// <param name="result">The result to post process. Can either be modified or fully overwritten.</param>
        protected virtual void PostProcessResult(ref BenchmarkResult result)
        {

        }
    }
}